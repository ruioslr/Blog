---
title: 树和图
categories:
 - 数据结构与算法
tags:
 - 数据结构与算法
---

# 树和图

## 树

### 定义：树（Tree）是n（n≥0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树T：
-（1）有且仅有一个称之为根的结点；
-（2）除根结点以外的其余结点可分为m（m>0）个互不相交的有限集T1, T2,…, Tm,其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

### 术语

- 节点： 树中的一个独立单元。包含一个数据元素及若干指向其子树的分支。
- 节点的度： 节点拥有的子树数（分支数）。
- 数的度： 各个几点的度的最大值。
- 叶子： 度为0的节点。
- 树的深度：树中结点的最大层次称为树的深度或高度。
- 森林：是m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。

就逻辑结构而言，任何一棵树都是一个二元组Tree＝(root , F)，其中root是数据元素，称作树的根结点；F是m（m≥0）棵树的森林，F=(T1, T2, …, Tm)，其中Ti=(ri, Fi)称作根root的第i棵子树；当m≠0时，在树根和其子树森林之间存在下列关系：

```
RF={<root,ri>|i=1,2,…,m,m>0
```

## 二叉树

二叉树与树的区别：

- 二叉树每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点）；
- 二叉树的子树有左右之分，其次序不能任意颠倒。

### 二叉树的性质

- 在二叉树的第i成上最多有2^(i-1)个节点, i >= 1。
- 深度为k的二叉树最多有2^k - 1 个节点。
- 叶子节点数n0,与度为2的节点n2的关系是： **n0 = n2 + 1**;

### 完全二叉树和满二叉树

**满二叉树**： 一棵深度为k且有2^k - 1 个借点的二叉树称为满二叉树。

**完全二叉树**： 深度为k，有n个节点的二叉树，当且仅当其每一个结点都与深度为k的**满二叉树**中编号从1至n的结点一一对应。

性质：

- 具有n个节点的完全二叉树的深度（log2 n） + 1

### 二叉树的存储结构

- 顺序存储结构
- 链式存储结构

**顺序存储结构**： 最坏的情况下，深度为k且只有k个节点的单只树却需要2^k -1 长度的一维数组。

#### 链式存储结构

包含左右指针和数据域称为**二叉链表**。

在二叉链表的基础上添加parent指针即为**三叉链表**。

在含有n的节点的二叉链表中有**n + 1个空链域**。

### 二叉树的遍历

- 先（根）序遍历
- 中（根）序遍历
- 后（根）序遍历

::: tips
遍历是递归的， 但可以使用栈来将递归算法转换成非递归算法，无论何种算法，时间复杂度都是O(n)，空间复杂度最坏的情况，即数据节点数是树的深度，也是O(n)。
:::

### 线索二叉树

若节点有左子树，则其lchild指向左子树，否则指向前驱，若有右子树，则指向右子树，否则指向后继。这样的树称为**线索二叉树**。

以某种次序遍历使二叉树变成线索二叉树的过程称为**线索化**


## 树和深林

### 树的存储结构

- 双亲表示法
- 孩子表示法
- 孩子兄弟表示法： 也叫二叉链表表示法。以二叉链表为存储结构，两个指针域分别指向firstChild和nextSibling。react的fiber Tree在这个基础上在加了一个return指向parent。

### 深林与二叉树的转换

#### 深林转换成二叉树

如果F={T1, T2,…, Tm}是森林，则可按如下规则转换成一棵二叉树B=(root, LB,RB)。
-（1）若F为空，即m=0，则B为空树；
-（2）若F非空，即m≠0，则B的根root即为森林中第一棵树的根ROOT(T1)；B的左子树LB是从T1中根结点的子树森林F1={T11, T12,…, T1m}转换而成的二叉树；其右子树RB是从森林F′={T2, T3, …, Tm}转换而成的二叉树。

#### 二叉树转换成深林

如果B=(root, LB, RB)是一棵二叉树，则可按如下规则转换成森林F={T1,T2，…, Tm}：
-（1）若B为空，则F为空；
-（2）若B非空，则F中第一棵树T1的根ROOT(T1)即为二叉树B的根root；T1中根结点的子树森林F1是由B的左子树LB转换而成的森林；F中除T1之外其余树组成的森林F′={T2, T3,…, Tm}是由B的右子树RB转换而成的森林。

从上述递归定义容易写出相互转换的递归算法。同时，森林和树的操作亦可转换成二叉树的操作来实现。

### 树和深林的遍历

#### 树的遍历

- 先根遍历
- 后根遍历

深林的遍历即为每棵树的依次遍历。

### 赫夫曼树及其应用

又叫**最优二叉树**，是一种带权路径长度最短的树。

定义：假设有以m个权值{w1, w2,…, wm}，可以构造一棵含n个叶子结点的二叉树，每个叶子结点的权为wi，则其中带权路径长度WPL最小的二叉树称做最优二叉树或哈夫曼树

赫夫曼算法： 

- （1）根据给定的n个权值{w1, w2,…, wn}，构造n棵只有根结点的二叉树，这n棵二叉树构成一个森林F。- 
- （2）在森林F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和。
- （3）在森林F中删除这两棵树，同时将新得到的二叉树加入F中。
- （4）重复（2）和（3），直到F只含一棵树为止。这棵树便是哈夫曼树。

::: tips
在构造哈夫曼树时，首先选择权小的，这样保证权大的离根较近，这样一来，在计算树的带权路径长度时，自然会得到最小带权路径长度，这种生成算法是一种典型的贪心法。
:::

## 图

图（Graph）G由两个集合V和E组成，记为G=(V, E)，其中V是顶点的有穷非空集合，E是V中顶点偶对的有穷集合，这些顶点偶对称为边。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。

对于无向图，若具有n(n−1)/2条边，则称为无向完全图。对于有向图，若具有n(n−1)条弧，则称为有向完全图。

**权和网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为**网**。


