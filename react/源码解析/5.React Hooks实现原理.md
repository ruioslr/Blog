---
title: React Hooks 实现原理
categories:
 - React
tags:
 - React源码
 - 源码
---

# React Hooks 实现原理

## 相关数据结构

* fiber
```js
type Fiber {

  memoizedState: null, // Hooks 链表

  stateNode: null, // 组件本身
}
```

* Hook

```ts
type Hook {
  memoizedState: any,   // 保存当前计算出来的state
  baseState: any,
  baseQueue: Update<any, any> | null, // 与React 对fiber更新那一章中 fiber.updateQueue.baseUpdate 链类似
  queue: UpdateQueue<any, any> | null,
  next: Hook | null,
}
```

* UpdateQueue
  
```ts
type UpdateQueue<S, A> = {|
  pending: Update<S, A> | null,
  dispatch: (A => mixed) | null,
  lastRenderedReducer: ((S, A) => S) | null,
  lastRenderedState: S | null,
|};
```

::: tip
注意： Fiber.memoizedState 和 Hook.memoizedState， 前者指向fiber对应的hooks链的头节点，后者表示单一hook的数据（useState和useReducer保存的是计算后的state, useEffect保存包含useEffect回调函数、依赖项等的链表数据结构effect）。
:::

## 使用dispather找到对应Hook

react会根据条件不同而使用不同的hooks

```js
ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;  
```

## useState 和 useReducer

我们把hooks的使用分为两个阶段：*声明阶段* 和 *调用阶段*。
*声明阶段
```js
const reducer = function(state, action){
    switch(action.type){
        case 'add':
        return state + action.payload
    }
}
const [number, setNumber] = useState(0);
const [number1, dispatch] = useReducer(reducer, 1);
```
*调用阶段
```js
setNumber(number => number + 1)
dispatch({type: 'add', payload: 2})
```

分别从两个阶段讲解源码是如何实现的：

### 声明阶段

#### mount 时
实际上*useState*和*useReducer*分别调用的是*mountState*和*mountReducer*方法：

::: details 查看这两个方法
```js

function mountState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  // 获取到WorkInProgressHook
  const hook = mountWorkInProgressHook();
  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: (initialState: any),
  });
  const dispatch: Dispatch<
    BasicStateAction<S>,
  > = (queue.dispatch = (dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue,
  ): any));
  return [hook.memoizedState, dispatch];
}


function mountReducer<S, I, A>(
  reducer: (S, A) => S,
  initialArg: I,
  init?: I => S,
): [S, Dispatch<A>] {
  const hook = mountWorkInProgressHook();
  let initialState;
  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = ((initialArg: any): S);
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: (initialState: any),
  });
  const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue,
  ): any));
  return [hook.memoizedState, dispatch];
}
```
:::

可以看到，这两个方法基本上一样，会先找到对应Hook，然后将初始值放在```hook.memoizedState```和```hook.baseState```上，接着创建一个更新队列（相当于fiber.updateQueue), 最后返回 ```[hook.memoizedState, dispatch]```;不同点是useReducer的*queue*返回的*lastRenderedReducer*是传入的*reducer*而*mountState*的是*basicStateReducer*。
这是*basicStateReducer*：
```js
function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}
```
### 调用阶段

调用阶段实际上是调用上一阶段返回的第二个参数：
```js
dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue,
)
```
::: details 查看dispatchAction的代码
```js

function dispatchAction<S, A>(
  fiber: Fiber,
  queue: UpdateQueue<S, A>,
  action: A,
) {
  const eventTime = requestEventTime();
  const suspenseConfig = requestCurrentSuspenseConfig();
  const lane = requestUpdateLane(fiber, suspenseConfig);

  const update: Update<S, A> = {
    eventTime,
    lane,
    suspenseConfig,
    action,
    eagerReducer: null,
    eagerState: null,
    next: (null: any),
  };

  // Append the update to the end of the list.
  const pending = queue.pending;
  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  queue.pending = update;

  const alternate = fiber.alternate;
  if (
    fiber === currentlyRenderingFiber ||
    (alternate !== null && alternate === currentlyRenderingFiber)
  ) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (
      fiber.lanes === NoLanes &&
      (alternate === null || alternate.lanes === NoLanes)
    ) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher;
        if (__DEV__) {
          prevDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }
        try {
          const currentState: S = (queue.lastRenderedState: any);
          const eagerState = lastRenderedReducer(currentState, action);
          // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.
          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {
          // Suppress the error. It will throw again in the render phase.
        } finally {
          if (__DEV__) {
            ReactCurrentDispatcher.current = prevDispatcher;
          }
        }
      }
    }
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}
```
:::

*dispatchAction*方法会创建一个update然后类似*setState*的更新一样将update拼接在*queue.pending*上形成一个单向环形链表。



## useEffect

## useRef

## useMemo 和 useCallback
